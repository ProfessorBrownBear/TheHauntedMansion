/**
 * ═══════════════════════════════════════════════════════════════════════════════
 * PASS BY REFERENCE & SHARED REFERENCES - VISUAL DEMONSTRATION
 * 
 * In Kotlin/Java:
 * - Primitives are passed by VALUE (copy of the value)
 * - Objects are passed by REFERENCE (copy of the memory address)
 * 
 * This means multiple variables can point to the SAME object!
 * ═══════════════════════════════════════════════════════════════════════════════
 */

/**
 * Bank Account - Our main object to demonstrate references
 */
class BankAccount(
    val accountNumber: String,
    var owner: String,
    var balance: Double
) {
    fun deposit(amount: Double) {
        balance += amount
        println("💵 Deposited $$amount → New balance: $$balance")
    }
    
    fun withdraw(amount: Double): Boolean {
        if (balance >= amount) {
            balance -= amount
            println("💸 Withdrew $$amount → New balance: $$balance")
            return true
        }
        println("❌ Insufficient funds! Balance: $$balance")
        return false
    }
    
    override fun toString() = "Account($accountNumber): $owner - $${"%.2f".format(balance)}"
}

/**
 * Visual helper to show memory state
 */
fun showMemoryDiagram(title: String, varName1: String, varName2: String = "", showsSameObject: Boolean = false) {
    println("\n┌─── $title ───")
    if (showsSameObject) {
        println("│")
        println("│  STACK                 HEAP")
        println("│  ─────                 ────")
        println("│  $varName1 ─────┐")
        println("│                 ├───→  [BankAccount Object]")
        println("│  $varName2 ─────┘       • accountNumber")
        println("│                          • owner")
        println("│                          • balance")
        println("│")
        println("│  ⚠️ Both variables point to the SAME object!")
    } else {
        println("│")
        println("│  STACK                 HEAP")
        println("│  ─────                 ────")
        println("│  $varName1 ─────────→  [BankAccount Object]")
        println("│                          • accountNumber")
        println("│                          • owner")
        println("│                          • balance")
    }
    println("└" + "─".repeat(50))
}

/**
 * Function that modifies account (demonstrates pass by reference)
 */
fun processTransaction(account: BankAccount, amount: Double, type: String) {
    println("\n📝 Inside processTransaction function:")
    println("   Received account: $account")
    
    when (type) {
        "deposit" -> account.deposit(amount)
        "withdraw" -> account.withdraw(amount)
    }
    
    // This modification affects the ORIGINAL object!
    println("   After transaction: $account")
}

/**
 * Function that tries to reassign parameter (won't affect original)
 */
fun tryToReassignAccount(account: BankAccount) {
    println("\n🔄 Inside tryToReassignAccount function:")
    println("   Received: $account")
    
    // This creates a LOCAL reference, doesn't affect original!
    var localAccount = account
    localAccount = BankAccount("NEW123", "New Owner", 0.0)
    
    println("   Local reassigned to: $localAccount")
    println("   But parameter still points to: $account")
}

/**
 * Demonstrate primitives are passed by value
 */
fun modifyPrimitive(value: Int): Int {
    var localValue = value
    localValue += 100
    println("   Inside function: localValue = $localValue")
    return localValue
}

fun main() {
    println("╔════════════════════════════════════════════════════════════════╗")
    println("║     PASS BY REFERENCE & SHARED REFERENCES - VISUAL DEMO      ║")
    println("╚════════════════════════════════════════════════════════════════╝")
    
    // ═══════════════════════════════════════════════════════════════════
    // PART 1: PRIMITIVES - Pass by Value
    // ═══════════════════════════════════════════════════════════════════
    println("\n═══════════════════════════════════════════════════════════════")
    println("  PART 1: PRIMITIVES - Pass by Value (Copy)")
    println("═══════════════════════════════════════════════════════════════")
    
    var myNumber = 42
    println("\n📊 Original number: $myNumber")
    
    println("\n🔢 Passing primitive to function...")
    val result = modifyPrimitive(myNumber)
    
    println("\n✅ After function call:")
    println("   Original myNumber: $myNumber")  // Unchanged!
    println("   Returned value: $result")
    
    println("\n💡 Primitives are COPIED when passed to functions!")
    println("   The function works with a copy, not the original.")
    
    // Visual representation
    println("""
    
    ┌─── How Primitives are Passed ───
    │
    │  myNumber = 42  ──┐
    │                   │ (copy value)
    │                   ▼
    │  function(value = 42)  // Gets a COPY
    │
    │  Original unchanged! ✅
    └──────────────────────────────────
    """.trimIndent())
    
    // ═══════════════════════════════════════════════════════════════════
    // PART 2: OBJECTS - Pass by Reference
    // ═══════════════════════════════════════════════════════════════════
    println("\n═══════════════════════════════════════════════════════════════")
    println("  PART 2: OBJECTS - Pass by Reference (Address)")
    println("═══════════════════════════════════════════════════════════════")
    
    val aliceAccount = BankAccount("ACC001", "Alice", 1000.0)
    println("\n🏦 Created account: $aliceAccount")
    
    showMemoryDiagram("Initial State", "aliceAccount")
    
    println("\n💰 Calling processTransaction(deposit $500)...")
    processTransaction(aliceAccount, 500.0, "deposit")
    
    println("\n🔍 Back in main - checking original:")
    println("   Alice's account: $aliceAccount")
    println("   ⚠️ Balance CHANGED! Function modified the ORIGINAL object!")
    
    println("\n💡 Objects are passed by REFERENCE!")
    println("   The function receives the memory address, not a copy.")
    
    // ═══════════════════════════════════════════════════════════════════
    // PART 3: SHARED REFERENCES - Multiple Variables, Same Object
    // ═══════════════════════════════════════════════════════════════════
    println("\n═══════════════════════════════════════════════════════════════")
    println("  PART 3: SHARED REFERENCES - Multiple Variables, One Object")
    println("═══════════════════════════════════════════════════════════════")
    
    val jointAccount = BankAccount("ACC002", "Bob & Carol", 2000.0)
    println("\n👫 Created joint account: $jointAccount")
    
    // Both variables point to the SAME account
    val bobsAccess = jointAccount
    val carolsAccess = jointAccount
    
    showMemoryDiagram("Shared References", "bobsAccess", "carolsAccess", true)
    
    // Check if they're the same object
    println("\n🔍 Reference Check:")
    println("   bobsAccess === carolsAccess: ${bobsAccess === carolsAccess}")
    println("   bobsAccess === jointAccount: ${bobsAccess === jointAccount}")
    println("   ✅ All TRUE - same object in memory!")
    
    // Bob makes a withdrawal
    println("\n👨 Bob withdraws $300...")
    bobsAccess.withdraw(300.0)
    
    // Carol checks the balance
    println("\n👩 Carol checks her access:")
    println("   Carol sees: $carolsAccess")
    println("   ⚠️ Bob's withdrawal affected Carol's view!")
    
    // Original variable also shows the change
    println("\n🏦 Original joint account: $jointAccount")
    println("   ⚠️ ALL variables see the same changes!")
    
    // ═══════════════════════════════════════════════════════════════════
    // PART 4: ASSIGNMENT - Creates Reference, Not Copy!
    // ═══════════════════════════════════════════════════════════════════
    println("\n═══════════════════════════════════════════════════════════════")
    println("  PART 4: ASSIGNMENT - Creates Reference, Not Copy")
    println("═══════════════════════════════════════════════════════════════")
    
    val originalAccount = BankAccount("ACC003", "David", 3000.0)
    println("\n🏦 Original account: $originalAccount")
    
    println("\n📋 Attempting 'backup' with assignment:")
    val backup = originalAccount  // This is NOT a backup!
    println("   backup = originalAccount")
    
    println("\n🔍 Are they the same object?")
    println("   backup === originalAccount: ${backup === originalAccount}")
    println("   ⚠️ TRUE - 'backup' is just another reference!")
    
    println("\n💸 Original account withdraws $1000...")
    originalAccount.withdraw(1000.0)
    
    println("\n😱 Checking 'backup':")
    println("   Backup account: $backup")
    println("   ❌ The 'backup' also shows the withdrawal!")
    
    println("""
    
    ┌─── Why Assignment Doesn't Create Copies ───
    │
    │  originalAccount ────┐
    │                      ├──→ [BankAccount@1234]
    │  backup = original ──┘     balance: 2000.0
    │
    │  Both point to SAME object!
    │  This is NOT a backup! ❌
    └────────────────────────────────────────────
    """.trimIndent())
    
    // ═══════════════════════════════════════════════════════════════════
    // PART 5: COLLECTIONS - Also Passed by Reference
    // ═══════════════════════════════════════════════════════════════════
    println("\n═══════════════════════════════════════════════════════════════")
    println("  PART 5: COLLECTIONS - Also Objects, Also Referenced")
    println("═══════════════════════════════════════════════════════════════")
    
    val accountsList = mutableListOf(
        BankAccount("ACC004", "Eve", 4000.0),
        BankAccount("ACC005", "Frank", 5000.0)
    )
    
    println("\n📋 Created list of accounts:")
    accountsList.forEach { println("   - $it") }
    
    // Function that modifies the list
    fun addVIPAccount(accounts: MutableList<BankAccount>) {
        println("\n🌟 Inside addVIPAccount function:")
        accounts.add(BankAccount("VIP001", "Grace (VIP)", 10000.0))
        println("   Added VIP account to list")
    }
    
    println("\n📞 Calling addVIPAccount...")
    addVIPAccount(accountsList)
    
    println("\n🔍 Back in main - checking original list:")
    println("   List size: ${accountsList.size}")
    accountsList.forEach { println("   - $it") }
    println("   ⚠️ Original list was modified!")
    
    // ═══════════════════════════════════════════════════════════════════
    // PART 6: REASSIGNMENT - Doesn't Affect Original Reference
    // ═══════════════════════════════════════════════════════════════════
    println("\n═══════════════════════════════════════════════════════════════")
    println("  PART 6: REASSIGNMENT - Local Only")
    println("═══════════════════════════════════════════════════════════════")
    
    val henryAccount = BankAccount("ACC006", "Henry", 6000.0)
    println("\n🏦 Henry's account: $henryAccount")
    
    tryToReassignAccount(henryAccount)
    
    println("\n🔍 Back in main - checking Henry's account:")
    println("   Henry's account: $henryAccount")
    println("   ✅ Unchanged! Reassignment in function was local only.")
    
    // ═══════════════════════════════════════════════════════════════════
    // SUMMARY
    // ═══════════════════════════════════════════════════════════════════
    println("\n╔════════════════════════════════════════════════════════════════╗")
    println("║                        KEY TAKEAWAYS                          ║")
    println("╠════════════════════════════════════════════════════════════════╣")
    println("║                                                                ║")
    println("║  PRIMITIVES (Int, Double, Boolean, etc.):                     ║")
    println("║  • Passed by VALUE (copy)                                     ║")
    println("║  • Function gets a copy                                       ║")
    println("║  • Original unchanged                                         ║")
    println("║                                                                ║")
    println("║  OBJECTS (including Collections):                             ║")
    println("║  • Passed by REFERENCE (memory address)                       ║")
    println("║  • Function gets address to same object                       ║")
    println("║  • Modifications affect original                              ║")
    println("║                                                                ║")
    println("║  ASSIGNMENT (=):                                              ║")
    println("║  • For objects: Copies the REFERENCE, not the object          ║")
    println("║  • Multiple variables can point to same object                ║")
    println("║  • Changes through any reference affect all                   ║")
    println("║                                                                ║")
    println("║  REFERENCE EQUALITY (===):                                    ║")
    println("║  • Checks if two variables point to SAME object               ║")
    println("║  • true = same object in memory                               ║")
    println("║  • false = different objects (even if equal content)          ║")
    println("║                                                                ║")
    println("║  REMEMBER:                                                    ║")
    println("║  When you pass an object to a function or assign it to        ║")
    println("║  another variable, you're sharing the SAME object!            ║")
    println("║                                                                ║")
    println("╚════════════════════════════════════════════════════════════════╝")
    
    // Final visual
    println("""
    
    ┌─── The Golden Rule ───
    │
    │  Primitives: COPIED 📋
    │  Objects: REFERENCED 👉
    │
    │  val x = 5
    │  val y = x         // y gets COPY of 5
    │
    │  val acc1 = BankAccount(...)
    │  val acc2 = acc1   // acc2 points to SAME account
    │
    └───────────────────────
    """.trimIndent())
}
