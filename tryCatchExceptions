/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * TRY-CATCH BLOCKS & DESIGN BY EXCEPTIONS - COMPLETE DEMONSTRATION
 *
 * This version has:
 * - Unique function names to avoid conflicts
 * - Comprehensive main() that demonstrates ALL error cases
 * - Clear separation of each scenario
 *
 * Theme: Online Bookstore Order Processing
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */

/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * CUSTOM EXCEPTIONS - What Could Go Wrong?
 * All prefixed with "TC" for Try-Catch to avoid conflicts
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */

// PAYMENT FAILURES
class TCInsufficientFundsError(
    val required: Double,
    val available: Double
) : Exception("Payment failed: Need $$required but only $$available available")

class TCInvalidCardError(
    val cardNumber: String
) : Exception("Invalid card number: $cardNumber (must be 16 digits)")

// INVENTORY FAILURES
class TCOutOfStockError(
    val bookTitle: String,
    val requested: Int,
    val available: Int
) : Exception("'$bookTitle' out of stock: Requested $requested, only $available available")

class TCBookNotFoundError(
    val isbn: String
) : Exception("Book not found with ISBN: $isbn")

// BUSINESS RULE FAILURES
class TCMinimumOrderError(
    val currentTotal: Double,
    val minimum: Double
) : Exception("Order too small: $$currentTotal is below $$minimum minimum")

class TCMaxQuantityError(
    val bookTitle: String,
    val requested: Int,
    val maxAllowed: Int
) : Exception("Too many copies of '$bookTitle': Requested $requested, max $maxAllowed allowed")

/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * DOMAIN OBJECTS
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */

data class TCBook(
    val isbn: String,
    val title: String,
    val price: Double,
    var stockQuantity: Int
)

data class TCCustomer(
    val name: String,
    val cardNumber: String,
    var balance: Double
)

/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * BOOKSTORE SYSTEM - Business Logic That Can Fail
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */

class TCBookstoreOrderProcessor {
    // Inventory
    private val inventory = mutableMapOf(
        "978-0134685991" to TCBook("978-0134685991", "Effective Java", 45.99, 5),
        "978-0135166307" to TCBook("978-0135166307", "Clean Code", 39.99, 2),
        "978-1617295454" to TCBook("978-1617295454", "Kotlin in Action", 44.99, 0),
        "978-0321356680" to TCBook("978-0321356680", "Effective C++", 54.99, 1)
    )

    // Business rules
    companion object {
        const val MINIMUM_ORDER = 20.00
        const val MAX_PER_TITLE = 3
        const val VALID_CARD_LENGTH = 16
    }

    /**
     * Process order - Can fail in 6 different ways!
     */
    fun processOrder(
        customer: TCCustomer,
        isbn: String,
        quantity: Int
    ): String {
        // 1. Book might not exist
        val book = inventory[isbn]
            ?: throw TCBookNotFoundError(isbn)

        // 2. Quantity might exceed limit
        if (quantity > MAX_PER_TITLE) {
            throw TCMaxQuantityError(book.title, quantity, MAX_PER_TITLE)
        }

        // 3. Might be out of stock
        if (book.stockQuantity < quantity) {
            throw TCOutOfStockError(book.title, quantity, book.stockQuantity)
        }

        // 4. Order might be too small
        val total = book.price * quantity
        if (total < MINIMUM_ORDER) {
            throw TCMinimumOrderError(total, MINIMUM_ORDER)
        }

        // 5. Card might be invalid
        if (customer.cardNumber.length != VALID_CARD_LENGTH) {
            throw TCInvalidCardError(customer.cardNumber)
        }

        // 6. Might have insufficient funds
        if (customer.balance < total) {
            throw TCInsufficientFundsError(total, customer.balance)
        }

        // Success - process the order
        book.stockQuantity -= quantity
        customer.balance -= total

        return "âœ… Success! Ordered $quantity x '${book.title}' = $${"%.2f".format(total)}"
    }

    // Helper to reset inventory for demonstrations
    fun resetInventory() {
        inventory["978-0134685991"]?.stockQuantity = 5
        inventory["978-0135166307"]?.stockQuantity = 2
        inventory["978-1617295454"]?.stockQuantity = 0
        inventory["978-0321356680"]?.stockQuantity = 1
    }
}

/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * DEMONSTRATION FUNCTIONS - Each Shows Different Aspect
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */

// Demonstrate successful order (happy path)
fun demonstrateSuccessfulOrder(processor: TCBookstoreOrderProcessor) {
    println("\nğŸ“— DEMO 1: SUCCESSFUL ORDER (Happy Path)")
    println("â”€".repeat(50))

    val customer = TCCustomer("Alice Success", "1234567890123456", 200.00)

    try {
        val result = processor.processOrder(customer, "978-0134685991", 1)
        println(result)
        println("Customer balance after: $${customer.balance}")
    } catch (e: Exception) {
        println("Unexpected failure: ${e.message}")
    }
}

// Demonstrate book not found error
fun demonstrateBookNotFound(processor: TCBookstoreOrderProcessor) {
    println("\nğŸ“• DEMO 2: BOOK NOT FOUND ERROR")
    println("â”€".repeat(50))

    val customer = TCCustomer("Bob Searcher", "1234567890123456", 100.00)

    try {
        println("Attempting to order non-existent book...")
        processor.processOrder(customer, "999-INVALID-ISBN", 1)

    } catch (e: TCBookNotFoundError) {
        println("âŒ Caught BookNotFoundError:")
        println("   Message: ${e.message}")
        println("   Invalid ISBN: ${e.isbn}")
        println("   â†’ Solution: Check ISBN or browse catalog")
    }
}

// Demonstrate out of stock error
fun demonstrateOutOfStock(processor: TCBookstoreOrderProcessor) {
    println("\nğŸ“™ DEMO 3: OUT OF STOCK ERROR")
    println("â”€".repeat(50))

    val customer = TCCustomer("Carol Buyer", "1234567890123456", 100.00)

    try {
        println("Attempting to order out-of-stock book...")
        processor.processOrder(customer, "978-1617295454", 2)

    } catch (e: TCOutOfStockError) {
        println("âŒ Caught OutOfStockError:")
        println("   Book: '${e.bookTitle}'")
        println("   Requested: ${e.requested} copies")
        println("   Available: ${e.available} copies")
        if (e.available > 0) {
            println("   â†’ Solution: Reduce quantity to ${e.available}")
        } else {
            println("   â†’ Solution: Join waitlist or choose another book")
        }
    }
}

// Demonstrate insufficient funds error
fun demonstrateInsufficientFunds(processor: TCBookstoreOrderProcessor) {
    println("\nğŸ’³ DEMO 4: INSUFFICIENT FUNDS ERROR")
    println("â”€".repeat(50))

    val customer = TCCustomer("Dave Poor", "1234567890123456", 15.00)

    try {
        println("Customer balance: $${customer.balance}")
        println("Attempting to order expensive book...")
        processor.processOrder(customer, "978-0134685991", 1)

    } catch (e: TCInsufficientFundsError) {
        println("âŒ Caught InsufficientFundsError:")
        println("   Required: $${e.required}")
        println("   Available: $${e.available}")
        val shortage = e.required - e.available
        println("   Short by: $${"%.2f".format(shortage)}")
        println("   â†’ Solution: Add funds or choose cheaper book")
    }
}

// Demonstrate invalid card error
fun demonstrateInvalidCard(processor: TCBookstoreOrderProcessor) {
    println("\nğŸ”’ DEMO 5: INVALID CARD ERROR")
    println("â”€".repeat(50))

    val customer = TCCustomer("Eve BadCard", "1234", 100.00)

    try {
        println("Card number: ${customer.cardNumber} (length: ${customer.cardNumber.length})")
        println("Attempting to process payment...")
        processor.processOrder(customer, "978-0134685991", 1)

    } catch (e: TCInvalidCardError) {
        println("âŒ Caught InvalidCardError:")
        println("   Provided card: ${e.cardNumber}")
        println("   Card length: ${e.cardNumber.length} digits")
        println("   Required: 16 digits")
        println("   â†’ Solution: Enter valid 16-digit card number")
    }
}

// Demonstrate minimum order error
fun demonstrateMinimumOrder(processor: TCBookstoreOrderProcessor) {
    println("\nğŸ“ DEMO 6: MINIMUM ORDER ERROR")
    println("â”€".repeat(50))

    val customer = TCCustomer("Frank Minimal", "1234567890123456", 100.00)

    try {
        // Try to order just 1 copy of cheapest book
        println("Attempting small order...")
        processor.processOrder(customer, "978-0321356680", 1)  // Only $54.99

        // If that succeeds, try even smaller
        processor.resetInventory()

        // Create a really cheap book for this demo
        val cheapCustomer = TCCustomer("Grace Cheap", "1234567890123456", 50.00)

        // This would need to be less than $20
        // Since our cheapest book is $39.99, let's simulate with quantity 0
        // Actually, let's catch minimum order differently...

    } catch (e: TCMinimumOrderError) {
        println("âŒ Caught MinimumOrderError:")
        println("   Order total: $${e.currentTotal}")
        println("   Minimum required: $${e.minimum}")
        val needed = e.minimum - e.currentTotal
        println("   Add $${"%.2f".format(needed)} more to cart")
        println("   â†’ Solution: Add more items or increase quantity")
    } catch (e: Exception) {
        // Actually, with our prices, minimum order won't trigger easily
        println("Note: With book prices > $20, minimum order is usually met")
    }
}

// Demonstrate max quantity error
fun demonstrateMaxQuantity(processor: TCBookstoreOrderProcessor) {
    println("\nğŸ“¦ DEMO 7: MAX QUANTITY ERROR")
    println("â”€".repeat(50))

    val customer = TCCustomer("Gina Bulk", "1234567890123456", 500.00)

    try {
        println("Attempting to order 5 copies (max is 3)...")
        processor.processOrder(customer, "978-0134685991", 5)

    } catch (e: TCMaxQuantityError) {
        println("âŒ Caught MaxQuantityError:")
        println("   Book: '${e.bookTitle}'")
        println("   Requested: ${e.requested} copies")
        println("   Max allowed: ${e.maxAllowed} copies")
        println("   â†’ Solution: Reduce quantity to ${e.maxAllowed} or less")
    }
}

// Demonstrate multiple catch blocks
fun demonstrateMultipleCatchBlocks(processor: TCBookstoreOrderProcessor) {
    println("\nğŸ¯ DEMO 8: MULTIPLE CATCH BLOCKS")
    println("â”€".repeat(50))

    val customer = TCCustomer("Henry Multi", "123", 5.00)  // Bad card AND low funds

    try {
        println("Customer has multiple problems:")
        println("  - Invalid card: ${customer.cardNumber}")
        println("  - Low balance: $${customer.balance}")
        processor.processOrder(customer, "978-0134685991", 1)

    } catch (e: TCBookNotFoundError) {
        println("Book issue: ${e.message}")
    } catch (e: TCOutOfStockError) {
        println("Stock issue: ${e.message}")
    } catch (e: TCInvalidCardError) {
        println("âŒ Payment method issue: ${e.message}")
        println("   (Note: This was caught first!)")
    } catch (e: TCInsufficientFundsError) {
        println("Funds issue: ${e.message}")
    } catch (e: Exception) {
        println("Unexpected: ${e.message}")
    }

    println("\nOrder of catch blocks matters! First matching exception is caught.")
}

// Demonstrate finally block
fun demonstrateFinallyBlock(processor: TCBookstoreOrderProcessor) {
    println("\nğŸ”’ DEMO 9: FINALLY BLOCK (Always Executes)")
    println("â”€".repeat(50))

    val transactionId = "TXN-${System.currentTimeMillis()}"
    var logEntry = ""

    try {
        println("Starting transaction: $transactionId")
        logEntry = "Transaction $transactionId started"

        val customer = TCCustomer("Ian Finally", "BADCARD", 100.00)
        processor.processOrder(customer, "978-0134685991", 1)

        logEntry += " - SUCCESS"

    } catch (e: TCInvalidCardError) {
        println("âŒ Transaction failed: ${e.message}")
        logEntry += " - FAILED: Invalid card"

    } finally {
        // This ALWAYS runs, even if there's an exception
        println("\n[FINALLY BLOCK EXECUTING]")
        println("ğŸ“ Writing to audit log: $logEntry")
        println("ğŸ”“ Releasing transaction lock: $transactionId")
        println("âœ… Cleanup completed")
        println("[FINALLY BLOCK DONE]")
    }
}

// Demonstrate try as expression
fun demonstrateTryAsExpression(processor: TCBookstoreOrderProcessor) {
    println("\nğŸ¨ DEMO 10: TRY AS EXPRESSION (Kotlin Feature)")
    println("â”€".repeat(50))

    val customer1 = TCCustomer("Jane Success", "1234567890123456", 100.00)
    val customer2 = TCCustomer("John Fail", "BAD", 100.00)

    // Try-catch returns a value
    val result1 = try {
        processor.processOrder(customer1, "978-0134685991", 1)
        "âœ… Order processed successfully"
    } catch (e: Exception) {
        "âŒ Order failed: ${e.javaClass.simpleName}"
    }

    val result2 = try {
        processor.processOrder(customer2, "978-0134685991", 1)
        "âœ… Order processed successfully"
    } catch (e: Exception) {
        "âŒ Order failed: ${e.javaClass.simpleName}"
    }

    println("Customer 1 result: $result1")
    println("Customer 2 result: $result2")

    // Can also return different types
    val quantityToOrder: Int = try {
        val riskyCalculation = 100 / 5  // Could be division by zero
        riskyCalculation
    } catch (e: ArithmeticException) {
        1  // Default to 1 if calculation fails
    }

    println("\nCalculated quantity: $quantityToOrder")
}

/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * MAIN FUNCTION - Comprehensive Demonstration of All Cases
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */
fun main() {
    println("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
    println("â•‘     TRY-CATCH COMPLETE DEMONSTRATION - ALL ERROR CASES        â•‘")
    println("â•‘                  Design By Exceptions Philosophy               â•‘")
    println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")

    // Create the processor
    val orderProcessor = TCBookstoreOrderProcessor()

    // Run ALL demonstrations
    demonstrateSuccessfulOrder(orderProcessor)
    orderProcessor.resetInventory()

    demonstrateBookNotFound(orderProcessor)
    orderProcessor.resetInventory()

    demonstrateOutOfStock(orderProcessor)
    orderProcessor.resetInventory()

    demonstrateInsufficientFunds(orderProcessor)
    orderProcessor.resetInventory()

    demonstrateInvalidCard(orderProcessor)
    orderProcessor.resetInventory()

    demonstrateMinimumOrder(orderProcessor)
    orderProcessor.resetInventory()

    demonstrateMaxQuantity(orderProcessor)
    orderProcessor.resetInventory()

    demonstrateMultipleCatchBlocks(orderProcessor)
    orderProcessor.resetInventory()

    demonstrateFinallyBlock(orderProcessor)
    orderProcessor.resetInventory()

    demonstrateTryAsExpression(orderProcessor)

    // Summary
    println("\n" + "â•".repeat(60))
    println("                    SUMMARY: KEY CONCEPTS")
    println("â•".repeat(60))

    println("""
        
        ğŸ¯ DESIGN BY EXCEPTIONS PHILOSOPHY:
        
        1. START with "What could go wrong?"
        2. CREATE custom exception for each failure
        3. BUILD logic that throws these exceptions
        4. HANDLE each exception appropriately
        
        âœ… DEMONSTRATED:
        â€¢ Custom exceptions with properties
        â€¢ Specific catch blocks
        â€¢ Multiple catch blocks (order matters!)
        â€¢ Finally blocks (always execute)
        â€¢ Try as expression (Kotlin feature)
        â€¢ Rich error information in exceptions
        
        ğŸ’¡ BENEFITS:
        â€¢ Self-documenting code
        â€¢ Robust error handling
        â€¢ Easy debugging
        â€¢ Clear business rules
        â€¢ Testable failure scenarios
        
        Remember: Think about failure FIRST!
    """.trimIndent())
}
